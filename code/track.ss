;;;; Main track tooling

;;; Markdown

;; transform sxml tree into tree of strings. the tree of strings can
;; be traversed outputting each node with `send-reply`.
(define (sxml->md tree)
  (cond
   ((nodeset? tree) (map sxml->md tree))
   ((pair? tree)
    (let* ((tag (name tree))
	   (name (symbol->string tag))
	   (content (content-raw tree)))
      (case tag
	((h1) `("# " ,@(map sxml->md content) "\n"))
	((h2) `("## " ,@(map sxml->md content) "\n"))
	((h3) `("### " ,@(map sxml->md content) "\n"))
	((h4) `("#### " ,@(map sxml->md content) "\n"))
	((h5) `("##### " ,@(map sxml->md content) "\n"))
	((h6) `("###### " ,@(map sxml->md content) "\n"))
	((item)
	 `("* " ,@(map sxml->md content) "\n"))
	((enum)
	 `("\n" ,@(map sxml->md content) "\n"))
	((link)
	 (unless (and (list? content) (= 2 (length content)))
	   (error 'sxml->md "incorrect link. provide description and url"
		  content))
	 `("[" ,(car content) "]" "(" ,(cadr content) ")"))
	((link-with-title)
	 (unless (and (list? content) (= 3 (length content)))
	   (error 'sxml->md "incorrect link. provide description and url and title"
		  content))
	 `("[" ,(car content) "](" ,(cadr content) " \"" ,(caddr content) "\")"))
	((sentence)
	 `(,@(map sxml->md content) "\n"))
	((nl)
	 "\n")
	(else (error 'sxml->md "unexpected tag" tag)))))
   ((string? tree) (list tree))
   ((symbol? tree) (list (symbol->string tree)))
   (else (error 'sxml->md "unexpected node" tree))))

;; a simple way to test the output. eventual goal is to generate the
;; markdown in docs/*
(define (put-md md)
  (let ((source (format "code/docs/~a.ss" md))
	(target (format "~a.md" (string-upcase
				 (symbol->string md)))))
    (load source)
    (apply send-reply (sxml->md content))))

;;; Config

;; output config.json from code/config.ss
(define (make-config)
  (let ((config.json "config.json"))
    (when (file-exists? config.json)
      (delete-file config.json))
    (with-output-to-file config.json
      (lambda ()
	(json-write (process-config))))))

;; preprocess nodes in config. currently removes exercises marked wip
(define (process-config)
  (map (lambda (x)
         (if (not (eq? (car x) 'exercises))
             x
             `(exercises . ,(remp (lambda (exercise)
                                    (memq 'wip (map car exercise)))
                                  (cdr x)))))
       track-config))

;; Check problem's entry in config for uuid and existence.
(define (check-config-for problem)
  (let ((exercisms (lookup 'exercises track-config)))
    (cond ((find (lambda (exercism)
                   (eq? problem (lookup 'slug exercism)))
                 exercisms)
           =>
           (lambda (config)
             (unless (assoc 'uuid config)
               (error 'check-config-for
                      "please set uuid"
                      problem))))
          (else (error 'check-config-for
                       "please add problem to config/config.ss"
                       problem)))))

;;; UUID

;; wrapper to read uuid generated by configlet from scheme
(define (configlet-uuid)
  (let ((from-to-pid (process "./bin/configlet uuid")))
    (let ((fresh-uuid (read (car from-to-pid))))
      (close-port (car from-to-pid))
      (close-port (cadr from-to-pid))
      (symbol->string fresh-uuid))))

;;; Problem Specifications

;; fetch the files in the given problem's directory
(define (get-problem-specification problem)
  (let* ((problem-dir (format "../problem-specifications/exercises/~a" problem))
	 (spec (directory-list problem-dir)))
    (map (lambda (file)
	   (format "~a/~a" problem-dir file))
	 spec)))

;; fetches the README.md file for a given problem
;; nb: likely be replaced by sxml configuration
(define (write-problem-description problem)
  (let ((file (find (lambda (spec)
		      (string=? "md" (path-extension spec)))
		    (get-problem-specification problem)))
	(dir (format "code/exercises/~a" problem)))
    (unless file
      (error 'get-problem-description "couldn't find description" problem))
    (system (format "mkdir -p ~a && cp ~a ~a/README.md"
		    dir file dir))))

;; reads the test specification for a given problem 
(define (get-test-specification problem)
  (let ((test-suite-file (find (lambda (spec)
				 (string=? "json" (path-extension spec)))
			       (get-problem-specification problem))))
    (unless test-suite-file
      (error 'get-test-specification "couldn't find test suite for" problem))
    (with-input-from-file test-suite-file json-read)))

;; list all the problems in the problem-specifications directory
(define (get-problem-list)
  (map string->symbol
       (directory-list "../problem-specifications/exercises")))

;;; Test suite

;; read the code/test.ss file as s-expressions
(define *test-definitions*
  (with-input-from-file "code/test.ss" read-all))

;;; Problem Implementations

;; table to hold problem implementations
(define *problem-table*
  (make-hash-table))

;; log a problem and its implementation to the problem table. The
;; implementation is specified as an association list with tests, and
;; file paths to the problem skeleton and the problem example
;; solution.
(define (put-problem! problem implementation)
  (for-each (lambda (aspect)
	      (unless (assoc aspect implementation)
		(error 'put-test! "problem does not implement" problem aspect)))
	    ;; test is an sexpression. skeleton and solution are file paths
	    '(test skeleton solution))
  (hashtable-set! *problem-table* problem implementation))

;; look up the problem in the problem table.
(define (get-problem problem)
  (let ((implementation (hashtable-ref *problem-table* problem #f)))
    (unless implementation
      (error 'get-test "no implementation" problem))
    implementation))

;;; Stubbing, Building, and Testing problems

;; Read the problem-specifications directory and generate a stub
;; implementation. TODO. when the problem is not there, generate a
;; stub anyway without the readme.
(define (stub-exercism problem)
  (format #t "setting up ~a~%" problem)
  (let* ((dir (format "code/exercises/~a" problem))
	 (implementation (format "~a/~a.ss" dir problem))
         ;; todo, add "properties" found in spec to stub skeleton and solution
	 (skeleton (format "~a/~a.scm" dir problem))
	 (solution (format "~a/example.scm" dir))
         ;; see code/exercises/anagram/anagram.ss for more information
	 (stub-implementation
	  `(,@'((define (parse-test test)
		  `(lambda ()
		     (test-success (lookup 'description test)
				   equal?
				   problem
				   (lookup 'input test)
				   (lookup 'expected test))))
		(define (spec->tests spec)
		  `(,@*test-definitions*
                    (define (test . args)
		      (apply run-test-suite
			     (list ,@(map parse-test (lookup 'cases spec)))
			     args)))))
	    (put-problem! ',problem
			  ;; fixme, quoted expression for test not working 
			  `((test . ,(spec->tests
				      (get-test-specification ',problem)))
			    (skeleton . ,,(path-last skeleton))
			    (solution . ,,(path-last solution))))))
	 (stub-solution `((define (,problem)
			    'implement-me!))))
    (when (file-exists? implementation)
      (error 'setup-exercism "implementation already exists" problem))
    (format #t "~~ getting description~%")
    (write-problem-description problem)
    (format #t "~~ writing stub implementation~%")
    (write-expression-to-file stub-implementation implementation)
    (format #t "~~ writing stub solution~%")
    (write-expression-to-file stub-solution skeleton)
    (format #t "~~ writing stub skeleton~%")
    (write-expression-to-file stub-solution solution)))

;; write the problem as specified in code/exercises/problem/* to
;; _build/exercises/problem/*. This is a temporary location to first
;; test the problem before writing to exercises/problem/*.
(define (build-exercism problem)
  (let ((implementation (get-problem problem)))
    (let* ((dir (format "_build/exercises/~a" problem))
	   (src (format "code/exercises/~a" problem))
	   (test.scm (format "~a/test.scm" dir))
	   (skeleton.scm (format "~a/~a" src (lookup 'skeleton implementation)))
	   (solution.scm (format "~a/~a" src (lookup 'solution implementation)))
	   (README.md (format "~a/README.md" src)))
      (format #t "writing _build/~a~%" problem)
      (system
       (format "mkdir -p ~a && cp ~a ~a && cp ~a ~a && cp ~a ~a"
	       dir skeleton.scm dir solution.scm dir README.md dir))
      (write-expression-to-file (lookup 'test implementation) test.scm))))

;; test the problem output in _build/exercises/problem/* by loading
;; _build/exercises/problem/problem.scm and
;; _build/exercises/problem/test.scm
(define (verify-exercism problem)
  (let ((dir (format "_build/exercises/~a" problem))
        (implementation (get-problem problem)))
    (check-config-for problem)
    (load (format "~a/test.scm" dir))
    (with-output-to-string
     (lambda ()
       (let ((example
	      (begin
		(load (format "~a/~a" dir (lookup 'solution implementation)))
		(test))))
	 (unless (eq? 'success example)
	   (error 'verify-output "bad implementation!" problem)))))
    (format #t "updating exercises/~a~%" problem)
    ;; for now hold off on using new problems 
    ;;    (system (format "rm -rf exercises/~a && cp -r ~a exercises/~a" problem dir problem))
    'done))

;; build all implementations in the problem table
(define (build-implementations)
  (vector-for-each build-exercism (hashtable-keys *problem-table*)))

;; test all builds specified as implemented
(define (verify-implementations)
  (for-each verify-exercism implementations))

(define implementations
  '(
    ;;    hello-world
    ;;    leap
    ;;    rna-transcription
    ;;    hamming
    ;;    grains
    ;;    anagram
    ;;    nucleotide-count
    ;;    atbash-cipher
    pascals-triangle
    ;;    sieve
    ;;    change
    ;;    knapsack
    ;;    sublist
    ))


